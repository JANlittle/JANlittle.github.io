<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust学习笔记 | JANlittle's Blog</title><meta name="author" content="JANlittle"><meta name="copyright" content="JANlittle"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="变量 基本   不可变、可变、常量：   123let a &#x3D; 0;	&#x2F;&#x2F; 不可变变量，但可以shadowinglet mut a &#x3D; 0;	&#x2F;&#x2F; 可变变量const A: i32 &#x3D; 0;	&#x2F;&#x2F; 常量，必须手动标注类型   变量解构   12345678910111213141516let (a, mut b): (bool,bool) &#x3D; (true, false);struct Struct">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust学习笔记">
<meta property="og:url" content="https://janlittle.github.io/2024/07/04/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="JANlittle&#39;s Blog">
<meta property="og:description" content="变量 基本   不可变、可变、常量：   123let a &#x3D; 0;	&#x2F;&#x2F; 不可变变量，但可以shadowinglet mut a &#x3D; 0;	&#x2F;&#x2F; 可变变量const A: i32 &#x3D; 0;	&#x2F;&#x2F; 常量，必须手动标注类型   变量解构   12345678910111213141516let (a, mut b): (bool,bool) &#x3D; (true, false);struct Struct">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://janlittle.github.io/images/misc/default_cover3.png">
<meta property="article:published_time" content="2024-07-03T16:30:38.000Z">
<meta property="article:modified_time" content="2024-07-03T16:32:15.107Z">
<meta property="article:author" content="JANlittle">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://janlittle.github.io/images/misc/default_cover3.png"><link rel="shortcut icon" href="/images/misc/avatar.jpg"><link rel="canonical" href="https://janlittle.github.io/2024/07/04/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-04 00:32:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/misc/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/misc/default_cover3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="JANlittle's Blog"><span class="site-name">JANlittle's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Rust学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-03T16:30:38.000Z" title="发表于 2024-07-04 00:30:38">2024-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-03T16:32:15.107Z" title="更新于 2024-07-04 00:32:15">2024-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9D%82%E4%B9%B1%E7%AC%94%E8%AE%B0/">杂乱笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Rust学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="变量">变量</h2>
<h3 id="基本">基本</h3>
<ul>
<li>
<p>不可变、可变、常量：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">0</span>;	<span class="comment">// 不可变变量，但可以shadowing</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;	<span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">const</span> A: <span class="type">i32</span> = <span class="number">0</span>;	<span class="comment">// 常量，必须手动标注类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>变量解构</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>,<span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    e: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line"></span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _</span></span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [a, b, c, d, e]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>整数类型</p>
<p><code>u8</code>~<code>u128</code>，<code>i8</code>~<code>i128</code></p>
<p><strong>不同类型的整数不能进行运算。</strong></p>
<p><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</p>
</li>
<li>
<p>序列(Range)</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="所有权与引用">所有权与引用</h3>
<ul>
<li><strong>基本类型及其复合的赋值不会转移所有权而是拷贝（例如，整数或整数数组），复合类型的赋值会转移所有权，函数的参数传递和返回值也是一样。</strong></li>
<li>可以通过<strong>引用</strong>来使用和修改变量，引用默认不可变，可变引用<code>&amp;mut</code>。</li>
<li><strong>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</strong></li>
<li>引用必须总是有效的</li>
</ul>
<h3 id="字符串与切片">字符串与切片</h3>
<ul>
<li>
<p>字符串字面量属于<code>&amp;str</code>类型，不可变引用，UTF-8编码。</p>
</li>
<li>
<p>切片语法：<code>&amp;s[start..end]</code>。类似于python，属于不可变引用</p>
</li>
<li>
<p>引用不是单纯的取地址，它是一个单独的类型，<code>&amp;str</code>就包括<code>str</code>的地址和长度。</p>
</li>
<li>
<p><code>String</code> 类型则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串</p>
</li>
<li>
<p><code>&amp;str</code>-&gt;<code>String</code></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="string">&quot;Hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>String</code>-&gt;<code>&amp;str</code></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>操作<code>String</code>：追加、插入、替换、删除、连接。具体看文档，有的操作会改变<code>String</code>本身，有的不会。</p>
</li>
<li>
<p>遍历字符与字节：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="元组">元组</h3>
<ul>
<li>
<p>内部元素的类型可以互不相同</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = tup.<span class="number">0</span>;	<span class="comment">// 访问元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="结构体">结构体</h3>
<ul>
<li>
<p>定义与创建</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1		<span class="comment">// 结构体更新语法，.. 语法表明凡是我们没有显式声明的字段，全部从 user1 中自动获取。需要注意的是 ..user1 必须在结构体的尾部使用。</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// user1 的部分字段所有权被转移到 user2 中：username 字段发生了所有权转移，作为结果，user1 无法再被使用。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>元组结构体</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>#[derive(Debug)] </code>来打印结构体的信息</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="枚举">枚举</h3>
<ul>
<li>
<p>可以统一同类不同种结构等的处理，使得可以函数可以统一处理，通过match来分类讨论。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m2</span> = Message::Move&#123;x:<span class="number">1</span>,y:<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m3</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Option</code> 枚举用于处理空值（<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html%EF%BC%89">https://doc.rust-lang.org/std/option/enum.Option.html）</a></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>; <span class="comment">// 赋None值时需要显示指定Option类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当不确定某些值在运行时是否会有空值时，可以使用Option 枚举来处理None，具体可使用match来控制对Some和None的处理。</li>
<li><strong>可以使用cloned方法将<code>Option&lt;&amp;T&gt;</code>转化为<code>Option&lt;T&gt;</code>。</strong></li>
</ul>
</li>
<li>
<p><code>Result</code>枚举用于返回错误（<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html%EF%BC%89">https://doc.rust-lang.org/std/result/enum.Result.html）</a></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(-<span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">is_ok</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Some error message&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">is_ok</span>(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组">数组</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];	<span class="comment">// a有5个元素，全部初始化为3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];	<span class="comment">// 切片</span></span><br></pre></td></tr></table></figure>
<ul>
<li>长度固定</li>
<li><strong>元素必须有相同的类型</strong></li>
<li>依次线性排列</li>
<li><strong>数组并没有实现<code>Index</code>特征，只有数组切片才有</strong></li>
</ul>
<h3 id="Vector">Vector</h3>
<ul>
<li>
<p>Vector是动态数组，里面的类型应该都是相同的</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();	<span class="comment">// 有时候需要手动标注Vec的类型</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);	<span class="comment">// 这里rustc自动推断v是&lt;i32&gt;类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = &amp;v[<span class="number">100</span>];	<span class="comment">// 会直接报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">100</span>);	<span class="comment">// 返回Option，这里返回None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果需要含有不同类型，应该考虑使用枚举或者特征对象。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    IpAddr::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    IpAddr::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征对象</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V4</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V6</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V6</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> IpAddr&gt;&gt; = <span class="built_in">vec!</span>[			<span class="comment">// 需要手动标注下类型</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        ip.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="HashMap">HashMap</h3>
<ul>
<li>
<p>创建，其中<code>key</code>必须实现<code>std::cmp::Eq</code>和<code>Hash</code>特征。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;		<span class="comment">// 必须</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_gems</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">my_gems.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;红宝石&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams_list</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    (<span class="string">&quot;中国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">100</span>),</span><br><span class="line">    (<span class="string">&quot;美国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;日本队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">50</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 方法在内部实际上支持生成多种类型的目标集合，因此我们需要通过类型标注 HashMap&lt;_,_&gt; 来提示编译器</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams_map</span>: HashMap&lt;_,_&gt; = teams_list.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);	<span class="comment">// 这里score是值的引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span>: <span class="type">i32</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);	<span class="comment">// 这里score是值本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖已有的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(old, <span class="title function_ invoke__">Some</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询新插入的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new</span> = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(new, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Yellow对应的值，若不存在则插入新值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Yellow&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*v, <span class="number">5</span>); <span class="comment">// 不存在，插入5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Yellow对应的值，若不存在则插入新值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Yellow&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*v, <span class="number">5</span>); <span class="comment">// 已经存在，因此50没有插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已有值基础上更新</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">// 根据空格来切分字符串(英文单词都是通过空格切分)</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="comment">// or_insert 返回了 &amp;mut v 引用，因此可以通过该可变引用直接修改 map 中对应的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="BTreeMap">BTreeMap</h3>
<p>类似于<code>HashMap</code>，但<code>BTreeMap</code> 保证条目<strong>按其键排序，key必须实现<code>Ord</code>特征。而<code>Ord</code>特征需要实现<code>Eq + PartialOrd</code>特征。</strong></p>
<p><strong>从 <code>BTreeMap::iter</code> 、 <code>BTreeMap::into_iter</code> 、 <code>BTreeMap::values</code> 或 <code>BTreeMap::keys</code> 等函数获得的迭代器按键顺序生成其项目。</strong></p>
<h2 id="函数">函数</h2>
<ul>
<li>
<p>声明</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">u32</span>, b: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数的位置可以随便放，每个函数参数都需要标注类型，用表达式返回值。</strong></p>
</li>
</ul>
<h2 id="流程控制">流程控制</h2>
<ul>
<li>
<p><code>if</code>语句</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>if语句可以作为表达式使用，返回值。使用if返回值时要注意类型要相同。</li>
</ul>
</li>
<li>
<p>循环</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> collection	<span class="comment">// 转移所有权</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;collection		<span class="comment">// 不可变借用</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> collection	<span class="comment">// 	可变借用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i, v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="number">1</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">  <span class="comment">// 在 Rust 中 _ 的含义是忽略该值或者类型的意思</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">5</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;	<span class="comment">// loop循环是无限循环，并且可以返回值</span></span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;	<span class="comment">// break可以返回一个值，类似return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模式匹配">模式匹配</h2>
<ul>
<li>
<p><code>match</code>通用形式</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>match</code>本身可作为表达式进行赋值，同时可以从模式中取出绑定的值：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColorRGB</span>(<span class="type">u16</span>, <span class="type">u16</span>, <span class="type">u16</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">        Action::<span class="title function_ invoke__">ChangeColorRGB</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions &#123;</span><br><span class="line">        <span class="keyword">match</span> action &#123;</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;point from (0, 0) move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">ChangeColorRGB</span>(r, g, _) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;change color into &#x27;(r:&#123;&#125;, g:&#123;&#125;, b:0)&#x27;, &#x27;b&#x27; has been ignored&quot;</span>, r, g,);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>if let</code>用于只匹配一个条件且忽略其它条件的情况</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123;	<span class="comment">// 做两件事：匹配，然后赋值，Some(3)可以换成Some(i)，这样i会被赋值为3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>matches!</code>宏将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> or <code>false</code></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(matches!(foo, <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bar</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(matches!(bar, <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vec是动态数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组尾部插入元素</span></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stack.pop从数组尾部弹出元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法">方法</h2>
<ul>
<li>
<p>可以为<strong>结构和枚举</strong>定义方法，格式：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span></span><br><span class="line">    <span class="comment">// 这种方法往往用于初始化当前结构体的实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>, radius: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Circle &#123;</span><br><span class="line">        Circle &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            y: y,</span><br><span class="line">            radius: radius,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Circle的方法，&amp;self/&amp;mut self表示借用当前的Circle结构体</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到方法和结构/枚举的定义是分开的，方法类型名要与对应的结构/枚举名相同。同时，可以多次定义impl块。</strong></p>
<p><strong>如果有泛型，需要在<code>impl</code>后用<code>&lt;&gt;</code>表明泛型参数。</strong></p>
</li>
<li>
<p>方法定义中参数不带self的函数是构造函数，被称为<code>关联函数</code>，需要通过<code>::</code>运算符来调用。一般使用<code>new</code>作为名字。</p>
</li>
<li>
<p>结构、类型和方法中的成员默认是私有的，需要添加<code>pub</code>关键字变为公有。</p>
</li>
</ul>
<h2 id="泛型-特征">泛型&amp;特征</h2>
<h3 id="泛型的使用">泛型的使用</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T,U&gt; &#123;	<span class="comment">//	泛型T和U既可以相同，也可以不同</span></span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为使用泛型的类型定义方法</span></span><br><span class="line"><span class="comment">// impl&lt;T, U&gt;表示T和U都是泛型而不是具体类型，Point&lt;T, U&gt;是一个完整的类型，不可少&lt;T, U&gt;</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;	</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为具体的泛型定义方法</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const-泛型（针对值的泛型）">const 泛型（针对值的泛型）</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特征定义">特征定义</h3>
<p>特征定义了<strong>一组可以被共享的行为，只要实现了特征，你就能使用这组行为</strong>。</p>
<p>如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。<strong>定义特征</strong>是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。</p>
<p><strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的！</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sheep</span> &#123; naked: <span class="type">bool</span>, name: <span class="type">String</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_naked</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.naked</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">shear</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">is_naked</span>() &#123;</span><br><span class="line">            <span class="comment">// `Sheep` 结构体上定义的方法可以调用 `Sheep` 所实现的特征的方法</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is already naked...&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">name</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; gets a haircut!&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.naked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数签名；`Self` 指代实现者的类型</span></span><br><span class="line">    <span class="comment">// 例如我们在为 Pig 类型实现特征时，那 `new` 函数就会返回一个 `Pig` 类型的实例，这里的 `Self` 指代的就是 `Pig` 类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法签名</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法还能提供默认的定义实现</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">talk</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; says &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">name</span>(), <span class="keyword">self</span>.<span class="title function_ invoke__">noise</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="comment">// `Self` 被替换成具体的实现者类型： `Sheep`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Sheep &#123;</span><br><span class="line">        Sheep &#123; name: name, naked: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">is_naked</span>() &#123;</span><br><span class="line">            <span class="string">&quot;baaaaah?&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;baaaaah!&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认的特征方法可以被重写</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">talk</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; pauses briefly... &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.<span class="title function_ invoke__">noise</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 这里的类型注释时必须的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dolly</span>: Sheep = Animal::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Dolly&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    dolly.<span class="title function_ invoke__">talk</span>();</span><br><span class="line">    dolly.<span class="title function_ invoke__">shear</span>();</span><br><span class="line">    dolly.<span class="title function_ invoke__">talk</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以通过<code>#[derive(...)]</code>为类型派生默认特征实现，如<code>Debug</code>等</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">  name: <span class="type">String</span>,</span><br><span class="line">  data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">  state: FileState,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特征约束">特征约束</h3>
<p><strong>在函数定义中，可以为参数进行特征约束：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以在指定类型 + 指定特征的条件下去实现方法：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>也可以有条件地实现特征：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特征可以被作为返回值类型被函数返回，但只能返回一个具体类型，多类型需要特征对象：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Weibo &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;m1 max太厉害了，电脑再也不会卡&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特征对象">特征对象</h3>
<ul>
<li>
<p>在针对实现某个特征的所有对象实现方法时，<strong>如果只需要同质（相同类型）集合，更倾向于采用泛型+特征约束这种写法</strong>，因其实现更清晰，且性能更好。但如果<strong>只单纯为实现了某个特征的所有类型实现方法，则应该考虑使用特征对象</strong>。<strong>可以通过 <code>&amp;dyn</code> 引用或者 <code>Box&lt;dyn T&gt;</code> 智能指针的方式来创建特征对象。</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;f64: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box&lt;T&gt; 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw&gt;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw1</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    <span class="comment">// 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法</span></span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw2</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="comment">// do_something(&amp;x);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box&lt;T&gt; 可以在函数调用时隐式地被转换为特征对象 Box&lt;dyn Draw&gt; </span></span><br><span class="line">    <span class="comment">// 基于 x 的值创建一个 Box&lt;f64&gt; 类型的智能指针，指针指向的数据被放置在了堆上</span></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x));</span><br><span class="line">    <span class="comment">// 基于 y 的值创建一个 Box&lt;u8&gt; 类型的智能指针</span></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(y));</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;x);</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用特征对象是由于rust需要在编译期确定函数参数和返回值的大小，通过返回Box或者引用可以将未知大小的特征对象包装成大小固定的引用对象。</strong></p>
</li>
<li>
<p>虽然特征对象没有固定大小，但它的引用类型的大小是固定的，它由两个指针组成（<code>ptr</code> 和 <code>vptr</code>），因此占用两个指针大小</p>
<p><strong>一个指针 <code>ptr</code> 指向实现了特征的具体类型的实例</strong></p>
<p><strong>另一个指针 <code>vptr</code> 指向一个虚表 <code>vtable</code>，<code>vtable</code> 中保存了类型的实例对于可以调用的实现于指定特征的方法，且只有这些方法。</strong></p>
<p>要注意，<strong>此时类型仅仅只是对应特征对象的实例，而不再是原先的类型，因此实例只能调用实现于指定特征的方法，而不能调用类型和类型实现于其他特征的方法。</strong></p>
</li>
<li>
<p>在 Rust 中，有两个<code>self</code>，<code>self</code>指代当前的实例对象，<code>Self</code>指代特征或者方法类型的别名</p>
</li>
<li>
<p>不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：</p>
<ul>
<li>方法的返回类型不能是 <code>Self</code></li>
<li>方法没有任何泛型参数</li>
</ul>
</li>
<li>
<p><strong>作为函数参数时，特征约束是静态分发，在编译期就会确定类型，直接使用类型特定的方法；特征对象会动态调用vtable中的方法，会有性能损耗。</strong></p>
</li>
</ul>
<h3 id="深入特征">深入特征</h3>
<ul>
<li>
<p><strong>关联类型</strong>：关联类型是在特征定义的语句块中，申明一个自定义类型，这样就可以在特征的方法签名中使用该类型。**<code>Self</code> 用来指代当前调用者的具体类型，那么 <code>Self::Item</code> 就用来指代该类型实现中定义的 <code>Item</code> 类型。**这种设计可以减少泛型的使用，提高可读性：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Counter&#123;..&#125;</span><br><span class="line">    c.<span class="title function_ invoke__">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>默认泛型类型参数</strong>：当使用泛型类型参数时，可以为其指定一个默认的具体类型。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示类型为Meters</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>调用同名方法</strong>：有时候特征和类型的有些方法名相同，可以通过命名空间进行调用，并且rust会优先调用类型上的方法。有些关联函数不能通过self指定，那可以使用<strong>完全限定语法</strong>调用：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>特征定义中的特征约束</strong>：有时候一个特征的实现依赖于其它特征，这时候就需要通过特征约束来约束特征，被称为<code>supertrait</code></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>在外部类型上实现外部特征(newtype)</strong>：由于孤儿规则，我们无法为外部类型实现外部特征。为了绕开这个限制，可以为指定类型多包装一层：为一个元组结构体创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，Rust 提供了一个特征叫<code>Deref</code>，实现该特征后，可以自动做一层类似类型转换的操作，可以将 <code>Wrapper</code> 变成 <code>Vec&lt;String&gt;</code> 来使用。这样就会像直接使用数组那样去使用 <code>Wrapper</code>，而无需为每一个操作都添加上 <code>self.0</code>。</p>
</li>
</ul>
<h3 id="一些重要的特征">一些重要的特征</h3>
<h4 id="Deref特征"><code>Deref</code>特征</h4>
<ul>
<li>
<p><strong>通过为类型 <code>T</code> 实现 <code>Deref&lt;Target = U&gt;</code> ，可以告诉编译器 <code>&amp;T</code> 和 <code>&amp;U</code> 在某种程度上可以互换。</strong></p>
</li>
<li>
<p>在不可变上下文中， <code>*v</code> （其中 <code>T</code> 既不是引用也不是原始指针）相当于 <code>*Deref::deref(&amp;v)</code> 。</p>
</li>
<li>
<p>对 <code>T</code> 的引用隐式转换为对 <code>U</code> 的引用（即 <code>&amp;T</code> 变为 <code>&amp;U</code> ）</p>
</li>
<li>
<p>可以调用 <code>&amp;T</code> 中<code>U</code> 上定义的所有以 <code>&amp;self</code> 作为输入的方法。</p>
</li>
<li>
<p>一般用于智能指针，在使用时编译器会在合适的地方插入<code>Deref::deref</code>方法。</p>
</li>
<li>
<pre><code class="language-rust">pub trait Deref &#123;
    type Target: ?Sized;

    // Required method
    fn deref(&amp;self) -&gt; &amp;Self::Target;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### `Sized`特征</span><br><span class="line"></span><br><span class="line">- **表示该类型的大小在编译时已知。**</span><br><span class="line">- 这个特征为**标记特征**和**自动特征**。</span><br><span class="line"></span><br><span class="line">#### `Error`特征</span><br><span class="line"></span><br><span class="line">- 用于在`Result`中表示错误类型。</span><br><span class="line"></span><br><span class="line">- `source`方法用于跨模块传递错误。</span><br><span class="line"></span><br><span class="line">- ```rust</span><br><span class="line">  pub trait Error: Debug + Display &#123;</span><br><span class="line">      fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#x27;static)&gt; &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  #[derive(Debug)]</span><br><span class="line">  struct SuperError &#123;</span><br><span class="line">      source: SuperErrorSideKick,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  impl fmt::Display for SuperError &#123;</span><br><span class="line">      fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">          write!(f, &quot;SuperError is here!&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  impl Error for SuperError &#123;</span><br><span class="line">      fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#x27;static)&gt; &#123;</span><br><span class="line">          Some(&amp;self.source)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h4 id="From-Into和TryFrom-TryInto"><code>From</code>/<code>Into</code>和<code>TryFrom</code>/<code>TryInto</code></h4>
<ul>
<li>
<p>这两对特征是孪生特征：实现了一个，另外一个就会跟着实现</p>
</li>
<li>
<pre><code class="language-rust">pub trait From&lt;T&gt;: Sized &#123;
    fn from(value: T) -&gt; Self;
&#125;

pub trait Into&lt;T&gt;: Sized &#123;
    fn into(self) -&gt; T;
&#125;

pub trait TryFrom&lt;T&gt;: Sized &#123;
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
&#125;

pub trait TryInto&lt;T&gt;: Sized &#123;
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### `Clone`与`Copy`特征</span><br><span class="line"></span><br><span class="line">- **实现`Clone`特征的类型能够完整地复制自身一份，包括栈上内存和管理的堆内存。这使得类型可以显式调用`clone()`方法来复制自己。**</span><br><span class="line">- **`Copy`特征是一个标记特征，它意味着该类型可以隐式地复制自己，使得能够在传递所有权的同时自身仍然能使用。它要求类型实现了`Clone`特征，并且不管理超出其在内存中占用的 `std::mem::size_of` 字节之外的任何其他资源（例如堆内存）。这意味着像String类型不能实现`Copy`特征。**</span><br><span class="line">- **绝大部分情况下，可以直接通过derive派生自动实现`Clone`与`Copy`特征。**</span><br><span class="line"></span><br><span class="line">#### `IntoIterator`与`Iterator`特征</span><br><span class="line"></span><br><span class="line">- `IntoIterator`特征用于将类型转换为迭代器。</span><br><span class="line"></span><br><span class="line">- `Iterator`特征表示该类型为迭代器。</span><br><span class="line"></span><br><span class="line">- ```rust</span><br><span class="line">  trait Iterator &#123;</span><br><span class="line">      type Item;</span><br><span class="line">      fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  trait IntoIterator &#123;</span><br><span class="line">      type Item;	// 表示每次迭代返回的元素类型</span><br><span class="line">      type IntoIter: Iterator&lt;Item = Self::Item&gt;;		// std::slice::Iter中的T为slice内部元素的类型</span><br><span class="line">      fn into_iter(self) -&gt; Self::IntoIter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<h4 id="Index与IndexMut特征"><code>Index</code>与<code>IndexMut</code>特征</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Index</span>&lt;Idx&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required method</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IndexMut</span>&lt;Idx&gt;: Index&lt;Idx&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Required method</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可以被自动derive派生的特征">可以被自动derive派生的特征</h3>
<ul>
<li>用于开发者输出的 <code>Debug</code></li>
<li>等值比较的 <code>PartialEq</code> 和 <code>Eq</code></li>
<li>次序比较的 <code>PartialOrd</code> 和 <code>Ord</code></li>
<li>复制值的 <code>Clone</code> 和 <code>Copy</code></li>
<li>固定大小的值映射的 <code>Hash</code></li>
<li>默认值的 <code>Default</code></li>
</ul>
<h2 id="生命周期">生命周期</h2>
<p><strong>当你在函数或结构中使用引用时，有时候编译器无法推断引用的生命周期长短，这时候就需要我们手动标注生命周期，以提示编译器引用之间的生命周期关系。</strong></p>
<h3 id="生命周期标注">生命周期标注</h3>
<p><strong>生命周期标注并不会改变任何引用的实际作用域，仅仅只是对编译器的提示功能，告诉编译器当不满足此约束条件时，就拒绝编译通过！！！</strong></p>
<ul>
<li>
<p><strong>函数签名格式</strong>如下：这里仅仅说明，x和y至少活得跟周期’a一样长，至于到底活多久或者哪个活得更久，抱歉我们都无法得知</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同泛型一样，需要先声明用到的生命周期&lt;&#x27;a&gt;，可以用&#x27;_占位</span></span><br><span class="line"><span class="comment">// 有些引用参数并不影响返回引用，可以不标注生命周期</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>结构体</strong>此时也可以使用引用：只要为结构体中的<strong>每一个引用标注上生命周期</strong>即可</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该生命周期标注说明，结构体 ImportantExcerpt 所引用的字符串 str 必须比该结构体活得更久。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>当结构体包含生命周期标注时，生命周期标注本身也成了结构体定义一部分，与泛型一样</strong>。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    a: &amp;<span class="symbol">&#x27;a</span> <span class="type">u32</span>,</span><br><span class="line">    b: &amp;<span class="symbol">&#x27;b</span> NoCopyType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fix_me</span>&lt;<span class="symbol">&#x27;a</span>&gt;(foo: &amp;Example&lt;<span class="symbol">&#x27;_</span>, <span class="symbol">&#x27;a</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> NoCopyType</span><br><span class="line">&#123; foo.b &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>方法的生命周期标注</strong>格式如下：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当&#x27;a和&#x27;b有明显先后关系时可以这样表示，用于说明 &#x27;a 必须比 &#x27;b 活得久</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>静态生命周期</strong>：<code>'static</code>，拥有该生命周期的引用可以和整个程序活得一样久。实在遇到解决不了的生命周期标注问题，可以尝试 <code>T: 'static</code>，有时候它会给你奇迹。</p>
</li>
</ul>
<h3 id="生命周期消除">生命周期消除</h3>
<p><strong>编译器为了简化用户的使用，运用了生命周期消除大法</strong>。这使得有些情况下我们不必为引用标注生命周期。<strong>目前消除规则仅针对函数，结构体仍需手动标注</strong>。</p>
<p>有2点需要注意：</p>
<ul>
<li>消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期</li>
<li><strong>函数或者方法中，参数的生命周期被称为 <code>输入生命周期</code>，返回值的生命周期被称为 <code>输出生命周期</code></strong></li>
</ul>
<p><strong>以下是消除规则：</strong></p>
<ol>
<li>**每一个引用参数都会获得独自的生命周期。**两个引用参数的有两个生命周期标注:<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code></li>
<li><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</strong>，也就是所有返回值的生命周期都等于该输入生命周期。函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>等同于 <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></li>
<li><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong>。这使得大多数方法不必标注生命周期。</li>
</ol>
<h2 id="返回值和错误处理">返回值和错误处理</h2>
<h3 id="panic-异常终止"><code>panic!</code>异常终止</h3>
<ul>
<li>
<p>可以主动进行调用：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认情况下，在提供命令行参数的情况下，<strong><code>Debug</code>模式触发<code>panic!</code>时会打印栈帧方便分析</strong>：</p>
<ul>
<li>Linux/macOS 等 UNIX 系统： <code>RUST_BACKTRACE=1 cargo run</code></li>
<li>Windows 系统（PowerShell）： <code>$env:RUST_BACKTRACE=1 ; cargo run</code></li>
</ul>
</li>
<li>
<p>当出现 <code>panic!</code> 时，程序提供了两种方式来处理终止流程：<strong>栈展开</strong>和<strong>直接终止</strong>。<strong>默认是栈展开</strong>。但可以修改 <code>Cargo.toml</code> 文件，实现在 <code>release</code> 模式下遇到 <code>panic</code> 直接终止：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = <span class="symbol">&#x27;abort</span>&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>main</code>线程触发<code>panic</code>会终止整个程序，子线程触发只会终止整个线程。</strong></p>
</li>
<li>
<p><strong>当调用 <code>panic!</code> 宏时，它会：</strong></p>
<ol>
<li>格式化 <code>panic</code> 信息，然后使用该信息作为参数，调用 <code>std::panic::panic_any()</code> 函数</li>
<li><code>panic_any</code> 会检查应用是否使用了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/panic/fn.set_hook.html"><code>panic hook</code></a>，如果使用了，该 <code>hook</code> 函数就会被调用（<code>hook</code> 是一个钩子函数，是外部代码设置的，用于在 <code>panic</code> 触发时，执行外部代码所需的功能）</li>
<li>当 <code>hook</code> 函数返回后，当前的线程就开始进行栈展开：从 <code>panic_any</code> 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行</li>
<li>展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 <code>catching</code> 的帧（通过 <code>std::panic::catch_unwind()</code> 函数标记），此时用户提供的 <code>catch</code> 函数会被调用，展开也随之停止：当然，如果 <code>catch</code> 选择在内部调用 <code>std::panic::resume_unwind()</code> 函数，则展开还会继续。</li>
</ol>
<p>还有一种情况，在展开过程中，如果展开本身 <code>panic</code> 了，那展开线程会终止，展开也随之停止。</p>
<p>一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 <code>panic</code>：对于 <code>main</code> 线程，操作系统提供的终止功能 <code>core::intrinsics::abort()</code> 会被调用，最终结束当前的 <code>panic</code> 进程；如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过 <code>std::thread::join()</code> 进行收集。</p>
</li>
</ul>
<h3 id="Result和"><code>Result</code>和<code>?</code></h3>
<ul>
<li>
<p><strong><code>Result</code>常用于函数返回值进行错误处理，定义如下：</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用<code>unwrap()</code>和<code>expect()</code>获取返回值，出现错误直接触发<code>panic</code>：</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();	<span class="comment">// 获取OK(T)中的T，如果是Err则直接panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同unwrap，只不过可以自定义错误提示信息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用<code>?</code>自动解析返回值和返回错误：</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?是一个宏，约等价于</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let mut f = match f &#123;</span></span><br><span class="line"><span class="comment">    // 打开文件成功，将file句柄赋值给f</span></span><br><span class="line"><span class="comment">    Ok(file) =&gt; file,</span></span><br><span class="line"><span class="comment">    // 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line"><span class="comment">    Err(e) =&gt; return Err(e),</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>?</code>会自动获取正确的值，当出现错误时会直接返回错误。这使得它在函数正常返回时能够将返回值自动提取并赋值，当出现错误时会终止函数并返回错误，及时止损，达成链式调用。使用形式：</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">xxx</span>()?;</span><br><span class="line"><span class="title function_ invoke__">xxx</span>()?.<span class="title function_ invoke__">yyy</span>()?;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>?</code>可以对错误类型进行隐式类型转换。因此只要函数返回的错误 <code>ReturnError</code> 实现了 <code>From&lt;OtherError&gt;</code> 特征，那么 <code>?</code> 就会自动把 <code>OtherError</code> 转换为 <code>ReturnError</code>。这种转换非常好用，意味着你可以用一个大而全的 <code>ReturnError</code> 来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">open_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;File, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>?</code>也可以被用来处理<code>Option</code>，效果差不多。</strong></p>
</li>
</ul>
<h2 id="包和模块">包和模块</h2>
<ul>
<li>
<p><strong><code>mod xxx;</code>用于将项目内的模块导入进该文件，类似于<code>import xxx</code>。</strong></p>
</li>
<li>
<p><strong><code>use xxx::yyy;</code>用于导入模块路径方便调用，以及引入第三方模块，类似于<code>from xxx import yyy</code>。特别地，可以用<code>use xxx::*;</code>导入xxx模块所有内容。当引入多个项时，可以用大括号括起来：<code>use xxx::&#123;self, yyy&#125;;</code>。同时，可以为引入的模块取别名：<code>use xxx::yyy as zzz;</code></strong></p>
</li>
<li>
<p>为了引入第三方模块，需要在<code>Cargo.toml</code>的<code>[dependencies]</code>进行添加，<code>VSCode</code>+<code>rust-analyzer</code>会自动拉取。</p>
</li>
<li>
<p>引入本地模块时，可以通过绝对路径或相对路径进行引入：</p>
<ul>
<li><strong>绝对路径</strong>，从包根开始，路径名以包名或者 <code>crate</code> 作为开头</li>
<li><strong>相对路径</strong>，从当前模块开始，以 <code>self</code>，<code>super</code> 或当前模块的标识符作为开头</li>
</ul>
</li>
<li>
<p><strong>将文件夹作为模块引入时，需要在同级目录下设有与文件夹同名的<code>.rs</code>文件。</strong></p>
</li>
</ul>
<h2 id="注释与文档">注释与文档</h2>
<ul>
<li>
<p>代码注释</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这是块注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文档注释：在代码中可以额外书写文档注释，并可以使用<code>cargo doc</code>生成HTML网页文档（可以使用<code>cargo doc --open</code>自动生成网页并打开）。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这是文档行注释</span></span><br><span class="line"><span class="comment">/// `add_one` 将指定值加1</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = my_crate::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这是文档块注释</span></span><br><span class="line"><span class="comment">`add_two` 将指定值加2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment">let arg = 5;</span></span><br><span class="line"><span class="comment">let answer = my_crate::add_two(arg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">assert_eq!(7, answer);</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 这是包级行注释</span></span><br><span class="line"><span class="comment">/*! 这是包级块注释 */</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">	包级注释要添加到包、模块的最上方！如lib.rs的最上方</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释需要位于 <code>lib</code> 类型的包中，例如 <code>src/lib.rs</code> 中</li>
<li>文档注释可以使用 <code>markdown</code>语法！例如 <code># Examples</code> 的标题，以及代码块高亮</li>
<li>被注释的对象需要使用 <code>pub</code> 对外可见，记住：文档注释是给用户看的，<strong>内部实现细节不应该被暴露出去</strong></li>
</ul>
</li>
<li>
<p>文档测试</p>
</li>
<li>
<p>文档注释的代码跳转</p>
</li>
</ul>
<h2 id="格式化输出">格式化输出</h2>
<h2 id="闭包与迭代器">闭包与迭代器</h2>
<h3 id="闭包">闭包</h3>
<ul>
<li>
<p>闭包类似于python的lambda函数，可以快速创建一个简单函数等。<strong>与一般函数不同的是，闭包可以捕获作用域中的变量。</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|param1| 返回表达式</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>闭包的类型会被编译器自动推断（也可手动定义），一旦类型被推断之后就无法被修改，也就是参数和返回值类型都已固定。同时，每个闭包都有单独的一个类型，即使两个闭包完全一样，也会生成不同的类型。</strong></p>
</li>
<li>
<p>闭包的类型可以用三个特征来表示：<strong><code>FnOnce</code>、<code>FnMut</code>、<code>Fn</code>。分别表示按值捕获变量、按可变引用捕获变量、按不可变引用捕获变量。一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。</strong></p>
</li>
<li>
<p>如果你想强制闭包取得捕获变量的所有权，可以在参数列表前添加 <code>move</code> 关键字，这种用法通常用于闭包的生命周期大于捕获变量的生命周期时，例如将闭包返回或移入其他线程。</p>
</li>
<li>
<p>如果闭包没有实现Copy特征，那么在调用一次之后会转移所有权，无法再次被调用。只要闭包捕获的类型都实现了<code>Copy</code>特征的话，这个闭包就会默认实现<code>Copy</code>特征。</p>
</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>
<p><strong>与迭代器相关的有两个主要特征：<code>IntoIterator</code>和<code>Iterator</code> 特征。实现了前者表示该类型可以转化为迭代器，实现了后者表示该类型是迭代器。</strong></p>
</li>
<li>
<p><strong>实现了<code>IntoIterator</code>特征的类型可以通过<code>into_iter</code>、<code>iter</code>、<code>iter_mut</code>三个方法生成不同的迭代器：<code>into_iter</code>会<em>夺走所有权</em>、<code>iter</code> 是<em>借用</em>、<code>iter_mut</code> 是<em>可变借用</em>。</strong></p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;I: <span class="built_in">Iterator</span>&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = I::Item;	<span class="comment">// 表示每次迭代返回的元素类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span> = I;		<span class="comment">// std::slice::Iter中的T为slice内部元素的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> I &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现了<code>Iterator</code>特征的类型为迭代器，可以被<code>for</code>循环使用，并且可以使用大量属于它的方法。<strong>要为自定义集合类型实现<code>Iterator</code>特征，最关键的是实现<code>next</code>方法</strong>：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其余有默认实现的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只要实现了<code>next</code>方法，<code>Iterator</code>其它方法都有基于<code>next</code>方法的默认实现，无需重复实现！</strong></p>
</li>
<li>
<p><code>next</code>方法是<strong>消耗性</strong>的，<strong>每次迭代都会消耗掉迭代器的一个元素</strong>，并返回<code>Option</code>枚举，当迭代器空时，便返回<code>None</code>。基于<code>next</code>方法的<code>Iterator</code>方法也会消耗迭代器元素。</p>
</li>
<li>
<p><strong><code>Iterator</code>的其它方法大致可分为消费者适配器和迭代器适配器。前者会消耗迭代器，后者会返回一个新迭代器。由于迭代器的惰性性质，迭代器适配器需要接一个消费者适配器来消耗，否则会报错。</strong></p>
</li>
<li>
<p>消费者适配器：<code>sum</code>、<code>collect</code>、<code>enumerate</code>、<code>zip</code>等，其中<code>collect</code>需要手动标注返回类型。</p>
</li>
<li>
<p>迭代器适配器：<code>map</code>、<code>filter</code>等，这些会接受一个闭包。</p>
</li>
<li>
<p>更多方法：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a></p>
</li>
</ul>
<h2 id="深入类型">深入类型</h2>
<h3 id="类型转换">类型转换</h3>
<ul>
<li>
<p><strong>可以使用<code>as</code>关键字和<code>TryInto</code>特征（可以用于处理转换错误）进行内置转换。一般用于小数值扩展到大数值。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.1</span> <span class="keyword">as</span> <span class="type">i8</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">100_i8</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>; <span class="comment">// 将字符&#x27;a&#x27;转换为整数，97</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,a,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i16</span> = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_</span>: <span class="type">u8</span> = <span class="keyword">match</span> b.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(b1) =&gt; b1,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编译器处理方法调用步骤：</strong></p>
<ul>
<li>首先，编译器检查它是否可以直接调用 <code>T::foo(value)</code>，称之为<strong>值方法调用</strong></li>
<li>如果上一步调用无法完成(例如方法类型错误或者特征没有针对 <code>Self</code> 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，例如会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li>
<li>若上面两个方法依然不工作，编译器会试着解引用 <code>T</code> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (<code>T</code> 可以被解引用为 <code>U</code>)，那么编译器会使用 <code>U</code> 类型进行尝试，称之为<strong>解引用方法调用</strong></li>
<li>若 <code>T</code> 不能被解引用，且 <code>T</code> 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 <code>T</code> 从定长类型转为不定长类型，例如将 <code>[i32; 2]</code> 转为 <code>[i32]</code></li>
</ul>
</li>
<li>
<p><strong>无视类型检查的强制转换：<code>mem::transmute&lt;T, U&gt;</code>和<code>mem::transmute_copy&lt;T, U&gt;</code>，属于unsafe！</strong></p>
</li>
</ul>
<h3 id="枚举与整数">枚举与整数</h3>
<p>要想实现像C语言那样的由整数组成的枚举，需要做一些转化。</p>
<ul>
<li>
<p>枚举可以轻松转化成整数(如使用<code>as</code>)，但整数无法直接转换成枚举。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 将枚举转换成整数，顺利通过</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = MyEnum::C <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换为枚举，失败</span></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        MyEnum::A =&gt; &#123;&#125;</span><br><span class="line">        MyEnum::B =&gt; &#123;&#125;</span><br><span class="line">        MyEnum::C =&gt; &#123;&#125;</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将整数转换成枚举，可以使用第三方库：<a target="_blank" rel="noopener" href="https://github.com/illicitonion/num_enum"><code>num_enums</code></a></strong></p>
</li>
<li>
<p>除此之外，也可以使用 <code>TryFrom</code> + 宏 或者 <code>std::mem::transmute</code> 来进行转化。</p>
</li>
</ul>
<h2 id="智能指针">智能指针</h2>
<p><strong>智能指针比一般的引用增加了一些特定的功能，它往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了 <code>Deref</code> 和 <code>Drop</code> 特征。</strong></p>
<table>
<thead>
<tr>
<th>Rust 规则</th>
<th>智能指针带来的额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个数据只有一个所有者</td>
<td><code>Rc/Arc</code>让一个数据可以拥有多个所有者</td>
</tr>
<tr>
<td>要么多个不可变借用，要么一个可变借用</td>
<td><code>RefCell</code>实现编译期可变、不可变引用共存</td>
</tr>
<tr>
<td>违背规则导致<strong>编译错误</strong></td>
<td>违背规则导致<strong>运行时<code>panic</code></strong></td>
</tr>
</tbody>
</table>
<h3 id="Box-T-堆对象分配">Box&lt;T&gt; 堆对象分配</h3>
<ul>
<li>Box智能指针可以强制将对象分配到堆中。</li>
<li>Box智能指针将动态大小类型变为 Sized 固定大小类型。</li>
<li><strong><code>Box::leak</code></strong>：它可以消费掉 <code>Box</code> 并且强制包含的对象从内存中泄漏。可以用于<strong>一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久</strong>。例如，在运行时加载的配置信息。可以使用<code>Box::from_raw</code>进行回收。</li>
</ul>
<h3 id="Deref-解引用">Deref 解引用</h3>
<ul>
<li>实现了<code>Deref</code>特征的<strong>引用类型</strong>可以自动解引用。</li>
<li><strong>一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>foo</code> 的引用 <code>&amp;foo</code> 在应用的时候会自动转换为 <code>&amp;U</code>。也就是说，解引用可以得到不同类型的引用。</strong></li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;T</code> 转换成 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;U</code>。</li>
</ul>
<h3 id="Drop-释放资源">Drop 释放资源</h3>
<ul>
<li>Drop特征的drop方法类似于析构函数。编译器会自动为几乎所有类型实现drop方法，即使你自行定义了drop方法，也会调用默认生成的drop方法。</li>
<li>可以通过调用<code>std::mem::drop</code>方法来手动释放变量，原理是传入所有权而不带出，离开作用域后自行调用<code>std::ops::Drop::drop()</code>实现。</li>
<li>无法为一个类型同时实现 <code>Copy</code> 和 <code>Drop</code> 特征。这是出于内存安全来考虑的。</li>
</ul>
<h3 id="Rc与Arc实现1对多所有权">Rc与Arc实现1对多所有权</h3>
<ul>
<li>
<p>当我们**希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用智能指针<code>Rc</code> 成为数据值的所有者。**例如，多线程、图数据结构时。<strong>这与多个不可变引用不是一个概念，多个不可变引用更多是作为“别名”的概念，不等同于同时拥有数据的所有权</strong>。**使用<code>Rc::clone</code>方法复制<code>Rc</code>指针。**具体用法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>Rc/Arc</code> 是不可变引用，一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的。</strong></p>
</li>
<li>
<p><strong>Rc 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 Arc，用法几乎相同。</strong></p>
</li>
<li>
<p>Rc 是一个智能指针，实现了 Deref 特征，因此你无需先解开 Rc 指针，再使用里面的 T，而是可以直接使用 T。</p>
</li>
</ul>
<h3 id="Cell与RefCell">Cell与RefCell</h3>
<p>允许在存在不可变引用的情况下对数据进行有限制的可变性，主要用于<strong>内部可变性</strong>。即在表面不可变的对象内部实现可变性。</p>
<ul>
<li>
<p>**<code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况，也就是说当T为简单类型时首选<code>Cell&lt;T&gt;</code>。**它永远不会提供<code>&amp;mut T</code>和产生<code>panic</code>。基本用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">one</span> = c.<span class="title function_ invoke__">get</span>();	<span class="comment">// 通过直接复制值来返回</span></span><br><span class="line">  c.<span class="title function_ invoke__">set</span>(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">two</span> = c.<span class="title function_ invoke__">get</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, one, two);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>RefCell&lt;T&gt;</code>适用于复杂类型，它产生引用，它将对不可变引用和可变引用的制约关系推断推迟到运行期检测</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">borrow_mut</span>();	<span class="comment">// 运行时报错，不能同时出现不可变和可变</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Cell</code>容器主要是为了解决内部可变性问题。**例如，对于一个结构，它的大部分内容都是不需要改变的，但内部有一些内容需要改变，这使得在一些只接受结构的不可变引用参数的方法和函数是无法更改其内部字段的。**此时，就可以<code>Cell</code>系列容器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="comment">// 定义在外部库中的特征</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;self, 整体的不可变借用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------</span></span><br><span class="line"><span class="comment">// 我们的代码中的数据结构和实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    msg_cache: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// 绕过整体的不可变借用，实现了内部可变性</span></span><br><span class="line">        <span class="keyword">self</span>.msg_cache.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mq</span> = MsgQueue &#123;</span><br><span class="line">        msg_cache: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    mq.<span class="title function_ invoke__">send</span>(<span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Rc容器是不可变的，可以在Rc容器内部引入Cell容器来获取可变性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;我很善变，还拥有多个主人&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// let mut s2 = s.borrow_mut();</span></span><br><span class="line">    s2.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, oh yeah!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, s, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Cell::from_mut</code>，该方法将 <code>&amp;mut T</code> 转为 <code>&amp;Cell&lt;T&gt;</code>。<code>Cell::as_slice_of_cells</code>，该方法将 <code>&amp;Cell&lt;[T]&gt;</code> 转为 <code>&amp;[Cell&lt;T&gt;]</code>。两个方法结合起来可以将<code>&amp;mut [T]</code> 类型转换成 <code>&amp;[Cell&lt;T&gt;]</code> 类型。</p>
</li>
<li>
<p><code>Cell</code>容器没有线程安全特性。</p>
</li>
</ul>
<h2 id="循环引用与自引用">循环引用与自引用</h2>
<h3 id="Weak-与循环引用">Weak 与循环引用</h3>
<ul>
<li>
<p>当出现循环引用时，Rc容器会导致引用计数无法正确归零，对象所占内存无法释放。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a的初始化rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a指向的节点 = &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建`b`到`a`的引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;在b创建后，a的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b的初始化rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b指向的节点 = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用RefCell的可变性，创建了`a`到`b`的引用</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;在更改a后，b的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;在更改a后，a的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行println!将导致循环引用</span></span><br><span class="line">    <span class="comment">// 8MB大小的main线程栈空间将被它冲垮，最终造成栈溢出</span></span><br><span class="line">    <span class="comment">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了解决<code>Rc</code>容器循环引用造成的内存泄露，可以使用<code>Weak</code>容器。<strong><code>Weak</code> 不持有所有权，它仅仅保存一份指向数据的弱引用</strong>：如果你想要访问数据，需要通过 <code>Weak</code> 指针的 <code>upgrade</code> 方法实现，该方法返回一个类型为 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 的值。</p>
</li>
<li>
<p>使用方式简单总结下：<strong>对于父子引用关系，可以让父节点通过 <code>Rc</code> 来引用子节点，然后让子节点通过 <code>Weak</code> 来引用父节点</strong>：</p>
<ul>
<li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li>
<li><strong>可由 <code>Rc&lt;T&gt;</code> 调用 <code>downgrade</code> 方法转换成 <code>Weak&lt;T&gt;</code></strong></li>
<li><strong><code>Weak&lt;T&gt;</code>可使用<code>upgrade</code>方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>来获取指向的对象，如果资源已经被释放，则<code>Option</code>的值是<code>None</code></strong></li>
<li>常用于解决循环引用的问题</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主人</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="type">Vec</span>&lt;Weak&lt;Gadget&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Owner</span></span><br><span class="line">    <span class="comment">// 需要注意，该 Owner 也拥有多个 `gadgets`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gadget_owner</span> : Rc&lt;Owner&gt; = Rc::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        Owner &#123;</span><br><span class="line">            name: <span class="string">&quot;Gadget Man&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            gadgets: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工具，同时与主人进行关联：创建两个 gadget，他们分别持有 gadget_owner 的一个引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gadget1</span> = Rc::<span class="title function_ invoke__">new</span>(Gadget&#123;id: <span class="number">1</span>, owner: gadget_owner.<span class="title function_ invoke__">clone</span>()&#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gadget2</span> = Rc::<span class="title function_ invoke__">new</span>(Gadget&#123;id: <span class="number">2</span>, owner: gadget_owner.<span class="title function_ invoke__">clone</span>()&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为主人更新它所拥有的工具</span></span><br><span class="line">    <span class="comment">// 因为之前使用了 `Rc`，现在必须要使用 `Weak`，否则就会循环引用</span></span><br><span class="line">    gadget_owner.gadgets.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;gadget1));</span><br><span class="line">    gadget_owner.gadgets.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;gadget2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 gadget_owner 的 gadgets 字段</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">gadget_opt</span> <span class="keyword">in</span> gadget_owner.gadgets.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gadget_opt 是一个 Weak&lt;Gadget&gt; 。 因为 weak 指针不能保证他所引用的对象</span></span><br><span class="line">        <span class="comment">// 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option&lt;_&gt;)来判</span></span><br><span class="line">        <span class="comment">// 断其所指向的对象是否存在。</span></span><br><span class="line">        <span class="comment">// 当然，Option 为 None 的时候这个引用原对象就不存在了。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">gadget</span> = gadget_opt.<span class="title function_ invoke__">upgrade</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Gadget &#123;&#125; owned by &#123;&#125;&quot;</span>, gadget.id, gadget.owner.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 main 函数的最后，gadget_owner，gadget1 和 gadget2 都被销毁。</span></span><br><span class="line">    <span class="comment">// 具体是，因为这几个结构体之间没有了强引用（`Rc&lt;T&gt;`），所以，当他们销毁的时候。</span></span><br><span class="line">    <span class="comment">// 首先 gadget2 和 gadget1 被销毁。</span></span><br><span class="line">    <span class="comment">// 然后因为 gadget_owner 的引用数量为 0，所以这个对象可以被销毁了。</span></span><br><span class="line">    <span class="comment">// 循环引用问题也就避免了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="结构体自引用">结构体自引用</h3>
<ul>
<li>
<p>结构体中同时存在一个值及其对应的引用，会导致所有权转移和借用相互冲突。</p>
</li>
<li>
<p>使用裸指针+<code>unsafe</code>+<code>Pin</code>来作为安全实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomPinned;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::ptr::NonNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一个自引用数据结构体，因为 slice 字段是一个指针，指向了 data 字段</span></span><br><span class="line"><span class="comment">// 我们无法使用普通引用来实现，因为违背了 Rust 的编译规则</span></span><br><span class="line"><span class="comment">// 因此，这里我们使用了一个裸指针，通过 NonNull 来确保它不会为 null</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    slice: NonNull&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    <span class="comment">// 为了确保函数返回时数据的所有权不会被转移，我们将它放在堆上，唯一的访问方式就是通过指针</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(data: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = Unmovable &#123;</span><br><span class="line">            data,</span><br><span class="line">            <span class="comment">// 只有在数据到位时，才创建指针，否则数据会在开始之前就被转移所有权</span></span><br><span class="line">            slice: NonNull::<span class="title function_ invoke__">dangling</span>(),</span><br><span class="line">            _pin: PhantomPinned,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">boxed</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">slice</span> = NonNull::<span class="title function_ invoke__">from</span>(&amp;boxed.data);</span><br><span class="line">        <span class="comment">// 这里其实安全的，因为修改一个字段不会转移整个结构体的所有权</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mut_ref</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt; = Pin::<span class="title function_ invoke__">as_mut</span>(&amp;<span class="keyword">mut</span> boxed);</span><br><span class="line">            Pin::<span class="title function_ invoke__">get_unchecked_mut</span>(mut_ref).slice = slice;</span><br><span class="line">        &#125;</span><br><span class="line">        boxed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unmoved</span> = Unmovable::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="comment">// 只要结构体没有被转移，那指针就应该指向正确的位置，而且我们可以随意移动指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">still_unmoved</span> = unmoved;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(still_unmoved.slice, NonNull::<span class="title function_ invoke__">from</span>(&amp;still_unmoved.data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们的类型没有实现 `Unpin` 特征，下面这段代码将无法编译</span></span><br><span class="line">    <span class="comment">// let mut new_unmoved = Unmovable::new(&quot;world&quot;.to_string());</span></span><br><span class="line">    <span class="comment">// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用第三方库：<a target="_blank" rel="noopener" href="https://github.com/joshua-maros/ouroboros">ouroboros</a>、<a target="_blank" rel="noopener" href="https://github.com/jpernst/rental">rental</a>、<a target="_blank" rel="noopener" href="https://github.com/Kimundi/owning-ref-rs">owning-ref</a></p>
</li>
</ul>
<h2 id="错误处理">错误处理</h2>
<h3 id="组合器">组合器</h3>
<p><strong>用于对返回结果的类型（<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/option/enum.Option.html">Option</a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/result/enum.Result.html">Result</a>）进行变换。</strong></p>
<ul>
<li><code>or()</code> 和 <code>and()</code>：<code>or()</code>，表达式按照顺序求值，若任何一个表达式的结果是 <code>Some</code> 或 <code>Ok</code>，则该值会立刻返回；<code>and()</code>，若两个表达式的结果都是 <code>Some</code> 或 <code>Ok</code>，则<strong>第二个表达式中的值被返回</strong>。若任何一个的结果是 <code>None</code> 或 <code>Err</code> ，则立刻返回。</li>
<li><code>or_else()</code> 和 <code>and_then()</code>：它们跟 <code>or()</code> 和 <code>and()</code> 类似，唯一的区别在于，它们的第二个表达式是一个闭包，会调用闭包，获取返回值。</li>
<li><code>filter</code>：<code>filter</code> 用于对 <code>Option</code> 进行过滤</li>
<li><code>map()</code> 和 <code>map_err()</code>：<code>map</code> 可以将 <code>Some</code> 或 <code>Ok</code> 中的值映射为另一个；<code>map_err</code>用于<code>Err</code></li>
<li><code>map_or()</code> 和 <code>map_or_else()</code>：<code>map_or</code> 在 <code>map</code> 的基础上提供了一个默认值；<code>map_or_else</code> 与 <code>map_or</code> 类似，但是它是通过一个闭包来提供默认值。</li>
<li><code>ok_or()</code> 和 <code>ok_or_else()</code>：这两兄弟可以将 <code>Option</code> 类型转换为 <code>Result</code> 类型。其中 <code>ok_or</code> 接收一个默认的 <code>Err</code> 参数；而 <code>ok_or_else</code> 接收一个闭包作为 <code>Err</code> 参数。</li>
</ul>
<h3 id="自定义错误类型">自定义错误类型</h3>
<ul>
<li>
<p><strong>自定义错误类型只需要实现 <code>Debug</code> 和 <code>Display</code> 特征即可。</strong></p>
</li>
<li>
<p>为自定义类型实现 <code>From</code> 特征以将其它错误类型转化为自定义类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    kind: <span class="type">String</span>,    <span class="comment">// 错误类型</span></span><br><span class="line">    message: <span class="type">String</span>, <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 AppError 实现 std::convert::From 特征，由于 From 包含在 std::prelude 中，因此可以直接简化引入。</span></span><br><span class="line"><span class="comment">// 实现 From&lt;io::Error&gt; 意味着我们可以将 io::Error 错误转换成自定义的 AppError 错误</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;io&quot;</span>),</span><br><span class="line">            message: error.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------- 上述代码运行后输出 ---------------</span></span><br><span class="line"><span class="comment">// Error: AppError &#123; kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="归一化不同的错误类型">归一化不同的错误类型</h3>
<p>当一个函数产生不同的错误类型时，返回错误类型需要做归一化：</p>
<ul>
<li>
<p>使用特征对象 <code>Box&lt;dyn Error&gt;</code></p>
</li>
<li>
<p>自定义错误类型，需要实现：<code>impl std::error::Error for MyError &#123;&#125;</code></p>
</li>
<li>
<p><strong>使用<a target="_blank" rel="noopener" href="https://github.com/dtolnay/thiserror"><code>thiserror</code></a>、<a target="_blank" rel="noopener" href="https://github.com/dtolnay/anyhow"><code>anyhow</code></a></strong></p>
<blockquote>
<p>如果你想要设计自己的错误类型，同时给调用者提供具体的信息时，就使用 <code>thiserror</code>，例如当你在开发一个三方库代码时。如果你只想要简单，就使用 <code>anyhow</code>，例如在自己的应用服务中。</p>
</blockquote>
</li>
</ul>
<h3 id="使用thiserror">使用<a target="_blank" rel="noopener" href="https://github.com/dtolnay/thiserror"><code>thiserror</code></a></h3>
<ul>
<li>为自定义错误类型（一般是错误类型枚举）自动派生<code>Error</code>特征：<code>#[derive(thiserror::Error)]</code></li>
<li><code>#[error(&quot;&#123;0&#125;&quot;)]</code> ：这是为自定义错误类型的每个枚举变量定义 <code>Display</code> 实现的语法。当显示错误时， <code>&#123;0&#125;</code> 将被变体的第 0 个字段替换。</li>
<li>可以添加<code>#[source]</code>或<code>#[from]</code>来自动实现<code>Error</code>特征的<code>source</code>方法。</li>
</ul>
<h2 id="unsafe-rust">unsafe rust</h2>
<p><a target="_blank" rel="noopener" href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</a></p>
<p>主要功能：</p>
<ul>
<li>解引用裸指针</li>
<li>调用一个 <code>unsafe</code> 或外部的函数</li>
<li>访问或修改一个可变的<a target="_blank" rel="noopener" href="https://course.rs/advance/global-variable.html#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">静态变量</a></li>
<li>实现一个 <code>unsafe</code> 特征</li>
<li>访问 <code>union</code> 中的字段</li>
</ul>
<p><strong>在unsafe中使用引用仍然会触发借用检查。</strong></p>
<h3 id="裸指针">裸指针</h3>
<ul>
<li>
<p>裸指针类型格式： <strong><code>*const T</code> 和 <code>*mut T</code></strong>，它们分别代表了不可变和可变。</p>
</li>
<li>
<p><strong>裸指针可以绕过Rust的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</strong></p>
</li>
<li>
<p><strong>创建裸指针是安全的行为，而解引用裸指针才是不安全的行为</strong></p>
</li>
<li>
<p>基于引用创建裸指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>基于智能指针创建裸指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Box</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 需要先解引用a</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;*a;</span><br><span class="line"><span class="comment">// 使用 into_raw 来创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: *<span class="keyword">const</span> <span class="type">i32</span> = <span class="type">Box</span>::<span class="title function_ invoke__">into_raw</span>(a);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="unsafe函数、方法与特征">unsafe函数、方法与特征</h3>
<ul>
<li>
<p>当调用unsafe函数时，你需要注意它的相关需求，因为 Rust 无法担保调用者在使用该函数时能满足它所需的一切需求。</p>
</li>
<li>
<p><code>unsafe</code> 无需套娃，在 <code>unsafe</code> 函数体中使用 <code>unsafe</code> 语句块是多余的行为。</p>
</li>
<li>
<p>之所以会有 <code>unsafe</code> 的特征，是因为该特征至少有一个方法包含有编译器无法验证的内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// 方法列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 实现相应的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="FFI（Foreign-Function-Interface）">FFI（Foreign Function Interface）</h3>
<ul>
<li>
<p>Rust调用外部函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在其它语言调用Rust函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实用工具-库">实用工具(库)</h3>
<ul>
<li><strong>rust-bindgen 和 cbindgen</strong>：对于 <code>FFI</code> 调用来说，保证接口的正确性是非常重要的，这两个库可以帮我们自动生成相应的接口，<strong>其中 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-bindgen"><code>rust-bindgen</code></a> 用于在 Rust 中访问 C 代码，而 <a target="_blank" rel="noopener" href="https://github.com/eqrion/cbindgen/"><code>cbindgen</code></a>则反之。</strong></li>
<li><strong>cxx</strong>：<strong>与C++交互，使用<a target="_blank" rel="noopener" href="https://github.com/dtolnay/cxx"><code>cxx</code></a></strong>，它提供了双向的调用，最大的优点就是安全：无需通过 <code>unsafe</code> 来使用它！</li>
<li><strong>Miri</strong>：<a target="_blank" rel="noopener" href="https://github.com/rust-lang/miri"><code>miri</code></a> 可以生成并模拟执行 Rust 的中间层表示 MIR。它可以帮助检查常见的未定义行为。</li>
<li><strong>Clippy</strong>：官方的 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-clippy"><code>clippy</code></a> 检查器提供了比<code>rustc</code>更强大的静态检查，其中包括有限的 <code>unsafe</code> 支持。<a target="_blank" rel="noopener" href="https://blog.csdn.net/cs583200859/article/details/124315134">原理</a></li>
<li>Prusti：<a target="_blank" rel="noopener" href="https://viperproject.github.io/prusti-dev/user-guide/"><code>prusti</code></a> 需要大家自己来构建一个证明，然后通过它证明代码中的不变量是正确被使用的，当你在安全代码中使用不安全的不变量时，就会非常有用。具体的使用文档见<a target="_blank" rel="noopener" href="https://viperproject.github.io/prusti-dev/user-guide/">这里</a>。</li>
<li>模糊测试(fuzz testing)：在 <a target="_blank" rel="noopener" href="https://rust-fuzz.github.io/book/">Rust Fuzz Book</a> 中列出了一些 Rust 可以使用的模糊测试方法。同时，我们还可以使用 <a target="_blank" rel="noopener" href="https://github.com/jakubadamw/rutenspitz"><code>rutenspitz</code></a> 这个过程宏来测试有状态的代码，例如数据结构。</li>
</ul>
<h3 id="内联汇编">内联汇编</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/advance/unsafe/inline-asm.html">course</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/inline-assembly.html">Rust Reference</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/unsafe/asm.html#clobbered-registers">Rust By Example</a></p>
<h2 id="Macro宏编程">Macro宏编程</h2>
<p><strong>特点：元编程、可变参数、编译期宏展开。</strong></p>
<p><strong>分类：声明式宏、过程宏（syntax extensions，语法扩展）。前者转化源码，后者生成源码。</strong></p>
<h3 id="声明式宏-macro-rules">声明式宏 macro_rules!</h3>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/macros-by-example.html">reference</a>、<a target="_blank" rel="noopener" href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></p>
<p>宏的声明在语法上类似match表达式。宏接受一段rust代码，并对这段代码进行匹配，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。也就是说，<strong>传入宏的这段源代码最终会被转化成另一段源代码</strong>，类似于C/C++中的宏。在调用上，类似与函数调用，只不过在名称后加<code>!</code>。如：<code>println!</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过程宏">过程宏</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/advance/macro.html#%E7%94%A8%E8%BF%87%E7%A8%8B%E5%AE%8F%E4%B8%BA%E5%B1%9E%E6%80%A7%E6%A0%87%E8%AE%B0%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">course</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/procedural-macros.html">reference</a></p>
<p>过程宏允许在编译时运行通过 Rust 语法运行的代码，生成 Rust 语法。可以将过程宏视为从一个 AST 到另一个 AST 的函数。<strong>过程宏必须在 crate 类型为 <code>proc-macro</code> 的 <em>lib crate</em> 中定义。可以选择嵌套crate来创建自定义过程宏。</strong></p>
<p>可以使用<code>cargo-expand</code>展开宏，查看自定义宏的正确性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-expand</span><br><span class="line">cargo <span class="built_in">expand</span> --bin hello_macro</span><br></pre></td></tr></table></figure>
<p>定义过程宏，需要在crate的<code>Cargo.toml</code>中添加：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.rs/syn/latest/syn/index.html">syn</a>：将rust的TokenStream转化为语法树。</strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.rs/quote/latest/quote/">quote</a>：将rust语法树转化为源代码。</strong></li>
</ul>
<p>对于过程宏定义，大致框架：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"><span class="keyword">use</span> syn::DeriveInput;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloMacro是特征，proc_macro_derive表示这是用于derive宏的</span></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="comment">// 基于 input 构建 AST 语法树</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span>:DeriveInput = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建特征实现代码</span></span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="derive过程宏"><code>derive</code>过程宏</h3>
<p><strong>只能用于struct、enum、union。</strong></p>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性宏">属性宏</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7264503343997304886">讲解</a></p>
<p>可以接受属性参数来生成代码。</p>
<p>使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get, &quot;/&quot;都是属性</span></span><br><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
<h3 id="类函数宏">类函数宏</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7264600679574224908">讲解</a></p>
<p>可以像函数那样调用，将参数转化为TokenStream，并生成新的代码。可以生成函数、闭包等。</p>
<p>使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM posts WHERE id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>
<h2 id="多线程并发编程">多线程并发编程</h2>
<h3 id="使用多线程">使用多线程</h3>
<ul>
<li>
<p>基本使用。<strong>要注意：因为Rust无法确定线程的存活时间，所以传递给线程的变量必须要转移它的所有权，也就是说线程要拿到变量所有权！这时候就需要move关键字。（或者，保证传递的是’static引用）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 线程使用的变量必须要获取它的所有权，用move关键字表示所有权的转移。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();	<span class="comment">// 让主线程阻塞，等待子线程返回退出，join()返回子线程的返回值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码会报错borrow of moved value: `v`</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用<strong>作用域线程确保线程作用域不超过父线程，从而更方便地使用父线程的变量</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">midpoint</span> = v.<span class="title function_ invoke__">len</span>() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Scope 生成的所有线程将在作用域结束时自动join。</span></span><br><span class="line">std::thread::<span class="title function_ invoke__">scope</span>(|scope| &#123;</span><br><span class="line">    scope.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first</span> = &amp;v[..midpoint];</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s the first half of v: &#123;first:?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    scope.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">second</span> = &amp;v[midpoint..];</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s the second half of v: &#123;second:?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s v: &#123;v:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当主线程结束时，其它子线程会强制结束，否则子线程会一直等到执行完再结束。</p>
</li>
<li>
<p><strong>可以使用 <code>Barrier</code> 让多个线程都执行到某个点后，才继续一起往后执行：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">barrier</span> = Arc::<span class="title function_ invoke__">new</span>(Barrier::<span class="title function_ invoke__">new</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = barrier.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">            b.<span class="title function_ invoke__">wait</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用 <code>thread_local</code> 宏可以初始化线程局部变量(每个线程都可持有的独立局部变量)，然后在线程内部使用该变量的 <code>with</code> 方法获取变量值。这种方法只能通过引用来使用变量：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line">thread_local!(<span class="keyword">static</span> FOO: RefCell&lt;<span class="type">u32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">    *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">    FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">        *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">3</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程完成</span></span><br><span class="line">t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span></span><br><span class="line">FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以在结构体中使用线程局部变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    thread_local! &#123;</span><br><span class="line">        <span class="keyword">static</span> FOO: RefCell&lt;<span class="type">usize</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Foo::FOO.<span class="title function_ invoke__">with</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::thread::LocalKey;</span><br><span class="line"></span><br><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> FOO: RefCell&lt;<span class="type">usize</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    foo: &amp;<span class="symbol">&#x27;static</span> LocalKey&lt;RefCell&lt;<span class="type">usize</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">constructor</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            foo: &amp;FOO,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用 <a target="_blank" rel="noopener" href="https://github.com/Amanieu/thread_local-rs">thread-local</a> 库，它允许每个线程持有线程局部变量的值的独立拷贝。</p>
</li>
<li>
<p>如果需要某个函数在多线程环境下只被调用一次，可以使用Once类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::Once;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> VAL: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle1</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;		<span class="comment">// INIT.call_once意味着这个方法只会被调用一次</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    handle2.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; VAL &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程同步：消息传递">线程同步：消息传递</h3>
<p>线程之间可以通过信道来通信，从而实现彼此之间的交互、内存访问、同步性等。<strong>它类似于一种多线程单所有权机制。</strong></p>
<ul>
<li>
<p><strong>标准库提供了通道<code>std::sync::mpsc</code>，该通道支持多个发送者，但是只支持唯一的接收者。通道只能发送和接收一个特定类型的数据。接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="comment">// 因为会转移所有权，所以多发送者需要clone</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// 需要使用move将tx的所有权转移到子线程的闭包中</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from raw tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx1.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from cloned tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>可以使用<code>try_recv</code>尝试接收一次消息，该方法并不会阻塞线程，当通道中没有消息时，它会立刻返回一个错误。</strong></p>
</li>
<li>
<p><strong>对于传递给通道的值，若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去；若值没有实现<code>Copy</code>，则它的所有权会被转移给接收端，在发送端继续使用该值将报错。</strong></p>
</li>
<li>
<p><code>mpsc::channel()</code>为异步通道，缓冲区无限，无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞；<code>mpsc::sync_channel</code>则为同步通道，同步通道<strong>发送消息是阻塞的，只有在消息被接收后才解除阻塞</strong>，参数为缓冲区大小。</p>
</li>
<li>
<p><strong>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</strong>。</p>
</li>
<li>
<p>可以使用多个通道或枚举来实现传输多种类型的数据。</p>
</li>
<li>
<p>如果需要多发送者，多接收者，可以考虑<a target="_blank" rel="noopener" href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel"><strong>crossbeam-channel</strong></a>库。</p>
</li>
</ul>
<h3 id="线程同步：锁、Condvar-和信号量">线程同步：锁、Condvar 和信号量</h3>
<p>线程之间可以通过共享内存(并发原语)来实现线程之间的交互。实现简洁、性能高，但会产生更多竞争。<strong>它类似于一种多线程多所有权机制。</strong></p>
<ul>
<li>
<p><strong><code>Arc&lt;T&gt;</code> + <code>Mutex&lt;T&gt;</code>：实现了多线程的内部可用性与多所有权。<code>Mutex&lt;T&gt;</code>是访问锁，无论读还是写，都只允许一个线程使用目标值。使用值时必须先加锁才能使用，手动drop或者离开变量域后将自动解锁。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// 这里可以使用try_lock方法，当无法加锁时将直接返回错误</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>RwLock</code>：使用方法<code>Mutex</code>类似，与允许并发读或写锁，在高并发读的情况下使用。但性能比<code>Mutex</code>低，且可能长时间获取不到写锁。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::RwLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间允许多个读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r1, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r2, <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="comment">// 读锁在此处被drop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间只允许一个写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = lock.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *w += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*w, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span></span><br><span class="line">        <span class="comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span></span><br><span class="line">        <span class="comment">// let r1 = lock.read();</span></span><br><span class="line">        <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span></span><br><span class="line">    &#125;<span class="comment">// 写锁在此处被drop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>第三方并发原语库可以获得比官方库更为强大的性能：<a target="_blank" rel="noopener" href="https://crates.io/crates/parking_lot">parking_lot</a></strong></p>
</li>
<li>
<p><strong>条件变量(<code>Condvar</code>)：和<code>Mutex</code>一起使用，可以让线程挂起，直到某个条件发生后再继续执行。这可以控制线程的执行顺序。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc,Mutex,Condvar&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;spawn,sleep&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flag</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cond</span> = Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cflag</span> = flag.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ccond</span> = cond.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hdl</span> = <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> !*lock &#123;</span><br><span class="line">                <span class="comment">// wait方法会接收一个MutexGuard&lt;&#x27;a, T&gt;，且它会自动地暂时释放这个锁，使其他线程可以拿到锁并进行数据更新。</span></span><br><span class="line">                <span class="comment">// 同时当前线程在此处会被阻塞，直到被其他地方notify后，它会将原本的MutexGuard&lt;&#x27;a, T&gt;还给我们，即重新获取到了锁，同时唤醒了此线程。</span></span><br><span class="line">                lock = ccond.<span class="title function_ invoke__">wait</span>(lock).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            *lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            counter += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        *flag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() = <span class="literal">true</span>;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter &gt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;outside counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        cond.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    hdl.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>信号量<code>Semaphore</code>：限制最大并发数。推荐使用<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio"><code>tokio</code></a>中提供的<code>Semaphore</code>实现。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semaphore</span> = Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">join_handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">permit</span> = semaphore.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">acquire_owned</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        join_handles.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里执行任务...</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(permit);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> join_handles &#123;</span><br><span class="line">        handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程同步：Atomic-原子类型与内存顺序">线程同步：Atomic 原子类型与内存顺序</h3>
<p>原子类型利用了原子指令，使得在cpu层面就实现了无锁并发原语，具有比锁更高的性能。常用于全局变量等。</p>
<ul>
<li>
<p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p>
<ul>
<li>代码中的先后顺序</li>
<li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li>
<li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li>
</ul>
</li>
<li>
<p>使用原子类型，需要根据需要设定内存屏障，确保正确的内存读写顺序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicBool&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        DATA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    READY.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">producer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            DATA = <span class="number">100</span>;                                 <span class="comment">// A</span></span><br><span class="line">        &#125;</span><br><span class="line">        READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);           <span class="comment">// B: 内存屏障 ↑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">consumer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Ordering::Acquire) &#123;&#125;         <span class="comment">// C: 内存屏障 ↓</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">100</span>, <span class="keyword">unsafe</span> &#123; DATA &#125;);               <span class="comment">// D</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_producer</span> = <span class="title function_ invoke__">producer</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_consumer</span> = <span class="title function_ invoke__">consumer</span>();</span><br><span class="line"></span><br><span class="line">        t_producer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        t_consumer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>原子类型缺陷：需要考虑的方面较多；只支持基本数值类型等。</p>
</li>
</ul>
<h3 id="Send-和-Sync">Send 和 Sync</h3>
<p><strong><code>Send</code>和<code>Sync</code>是标记特征（不定义任何行为），它们限定了哪些类型是可以安全地在线程间传递的。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc源码片段</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc源码片段</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实现<code>Send</code>的类型可以在线程间安全的传递其所有权。</strong></li>
<li><strong>实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)。</strong></li>
<li><strong>若类型 T 的引用<code>&amp;T</code>是<code>Send</code>，则<code>T</code>是<code>Sync</code></strong>。</li>
<li><strong>几乎所有类型都默认实现了<code>Send</code>和<code>Sync</code></strong>，而且由于这两个特征都是可自动派生的特征(通过<code>derive</code>派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了<code>Send</code>或者<code>Sync</code>，那么它就自动实现了<code>Send</code>或<code>Sync</code>。</li>
</ul>
<h2 id="全局变量">全局变量</h2>
<h3 id="编译期初始化">编译期初始化</h3>
<p><strong>无法用函数进行静态初始化</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态常量</span></span><br><span class="line"><span class="keyword">const</span> MAX_ID: <span class="type">usize</span> =  <span class="type">usize</span>::MAX / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> REQUEST_RECV: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 原子类型</span></span><br><span class="line"><span class="keyword">static</span> REQUEST_RECV: AtomicUsize  = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   	<span class="built_in">println!</span>(<span class="string">&quot;用户ID允许的最大值是&#123;&#125;&quot;</span>,MAX_ID);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问静态变量需要unsafe</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        REQUEST_RECV += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(REQUEST_RECV, <span class="number">1</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        REQUEST_RECV.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;当前用户请求数&#123;:?&#125;&quot;</span>,REQUEST_RECV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行期初始化">运行期初始化</h3>
<ul>
<li>
<p><strong>使用<code>Box::leak</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">init</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Config&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        a: <span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        b: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        CONFIG = <span class="title function_ invoke__">init</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.OnceLock.html">sync::OnceLock</a>（1.70版本以后）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::OnceLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hashmap</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> HASHMAP: OnceLock&lt;HashMap&lt;<span class="type">u32</span>, &amp;<span class="type">str</span>&gt;&gt; = OnceLock::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    HASHMAP.<span class="title function_ invoke__">get_or_init</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// First access to `HASHMAP` initializes it</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, <span class="title function_ invoke__">hashmap</span>().<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any further access to `HASHMAP` just returns the computed value</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `1` is \&quot;&#123;&#125;\&quot;.&quot;</span>, <span class="title function_ invoke__">hashmap</span>().<span class="title function_ invoke__">get</span>(&amp;<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<a target="_blank" rel="noopener" href="https://github.com/rust-lang-nursery/lazy-static.rs"><code>lazy_static</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HASHMAP: HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 首次访问`HASHMAP`的同时对其进行初始化</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续的访问仅仅获取值，再不会进行任何初始化操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `1` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="异步编程">异步编程</h2>
<p>Rust异步编程基于<code>async/await</code>模型，并提供了基于**内置语法（<code>async/await</code>）+官方库（future）+第三方异步运行时库（tokio）**的综合实现。</p>
<p><code>async</code>标注的函数或语句块会产生一个Future，相当于一个能够产生值的任务。当线程执行Future时，遇到阻塞后会搁置当前Future执行，转而执行其它Future，直到原Future不再阻塞，调用wake方法唤醒并继续执行当前任务。</p>
<p>Future要被执行，需要被执行器poll到，或者由<code>.await</code>关键字主动唤醒。</p>
<p>有点复杂。。后面结合tokio再看看</p>
<h2 id="自动化测试">自动化测试</h2>
<h3 id="测试编写">测试编写</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/test/write-tests.html">course</a></p>
<p>测试函数往往会被整合到一些单独的测试模块中，同时使用<code>#[test]</code>进行标注。</p>
<p>运行<code>cargo test</code>可以运行所有测试，并且可以添加参数从而控制测试的执行，例如执行一部分测试、指定测试用例的执行线程数等。</p>
<p>可以使用panic和assert等进行测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单元测试与集成测试">单元测试与集成测试</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/test/unit-integration-test.html">course</a></p>
<ul>
<li>
<p>单元测试目标是测试某一个代码单元(一般都是函数)，验证该单元是否能按照预期进行工作，例如测试一个 <code>add</code> 函数，验证当给予两个输入时，最终返回的和是否符合预期。在 Rust 中，单元测试的惯例是将测试代码的模块跟待测试的正常代码放入同一个文件中。对于这种测试模块，需要使用<code>#[cfg(test)]</code> 进行标注。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>集成测试文件放在项目根目录下的 <code>tests</code> 目录中，由于该目录下每个文件都是一个包，我们必须要引入待测试的代码到当前包的作用域中，才能进行测试，正因为此，集成测试只能对声明为 <code>pub</code> 的 API 进行测试。需要注意，<code>tests</code> 目录下的子目录文件不会被作为测试。运行<code>cargo test --test</code>来只运行集成测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GitHub-Actions（CI）">GitHub Actions（CI）</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/test/ci.html">course</a></p>
<p>可以编写GitHub Actions脚本，由GitHub自动化进行集成测试。可以使用其它项目的脚本。</p>
<h3 id="基准测试benchmark">基准测试benchmark</h3>
<p><a target="_blank" rel="noopener" href="https://course.rs/test/benchmark.html">course</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://JANlittle.github.io">JANlittle</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://janlittle.github.io/2024/07/04/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://janlittle.github.io/2024/07/04/Rust学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JANlittle.github.io" target="_blank">JANlittle's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a></div><div class="post_share"><div class="social-share" data-image="/images/misc/default_cover3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/05/%E4%BD%BF%E7%94%A8qiling%E5%87%BB%E8%B4%A5Pluto-Obfuscator%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%89%88%E5%B9%B3%E5%9D%A6%E5%8C%96/" title="使用qiling击败Pluto-Obfuscator的增强版平坦化"><img class="cover" src="/images/misc/default_cover1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用qiling击败Pluto-Obfuscator的增强版平坦化</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/03/hello-world/" title="hexo简易使用"><img class="cover" src="/images/misc/default_cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo简易使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/05/Rust-OLLVM%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%9A%84%E9%82%AA%E6%81%B6%E7%BB%84%E5%90%88/" title="Rust+OLLVM平坦化的邪恶组合"><img class="cover" src="/images/misc/default_cover4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-05</div><div class="title">Rust+OLLVM平坦化的邪恶组合</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/misc/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JANlittle</div><div class="author-info__description">JANlittle的随笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">所有权与引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">1.3.</span> <span class="toc-text">字符串与切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.6.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">1.8.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">1.9.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTreeMap"><span class="toc-number">1.10.</span> <span class="toc-text">BTreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-%E7%89%B9%E5%BE%81"><span class="toc-number">6.</span> <span class="toc-text">泛型&amp;特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">泛型的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%B3%9B%E5%9E%8B%EF%BC%88%E9%92%88%E5%AF%B9%E5%80%BC%E7%9A%84%E6%B3%9B%E5%9E%8B%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">const 泛型（针对值的泛型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89"><span class="toc-number">6.3.</span> <span class="toc-text">特征定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.4.</span> <span class="toc-text">特征约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.5.</span> <span class="toc-text">特征对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%89%B9%E5%BE%81"><span class="toc-number">6.6.</span> <span class="toc-text">深入特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">6.7.</span> <span class="toc-text">一些重要的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deref%E7%89%B9%E5%BE%81"><span class="toc-number">6.7.1.</span> <span class="toc-text">Deref特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#From-Into%E5%92%8CTryFrom-TryInto"><span class="toc-number">6.7.2.</span> <span class="toc-text">From&#x2F;Into和TryFrom&#x2F;TryInto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Index%E4%B8%8EIndexMut%E7%89%B9%E5%BE%81"><span class="toc-number">6.7.3.</span> <span class="toc-text">Index与IndexMut特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%87%AA%E5%8A%A8derive%E6%B4%BE%E7%94%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">6.8.</span> <span class="toc-text">可以被自动derive派生的特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">7.1.</span> <span class="toc-text">生命周期标注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="toc-number">7.2.</span> <span class="toc-text">生命周期消除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">返回值和错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2"><span class="toc-number">8.1.</span> <span class="toc-text">panic!异常终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Result%E5%92%8C"><span class="toc-number">8.2.</span> <span class="toc-text">Result和?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">包和模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E6%A1%A3"><span class="toc-number">10.</span> <span class="toc-text">注释与文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">11.</span> <span class="toc-text">格式化输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.</span> <span class="toc-text">闭包与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">12.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.2.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">深入类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">13.1.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%95%B4%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">枚举与整数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">14.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Box-T-%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">14.1.</span> <span class="toc-text">Box&lt;T&gt; 堆对象分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deref-%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">Deref 解引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">14.3.</span> <span class="toc-text">Drop 释放资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rc%E4%B8%8EArc%E5%AE%9E%E7%8E%B01%E5%AF%B9%E5%A4%9A%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">14.4.</span> <span class="toc-text">Rc与Arc实现1对多所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cell%E4%B8%8ERefCell"><span class="toc-number">14.5.</span> <span class="toc-text">Cell与RefCell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">循环引用与自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Weak-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">15.1.</span> <span class="toc-text">Weak 与循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">15.2.</span> <span class="toc-text">结构体自引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%99%A8"><span class="toc-number">16.1.</span> <span class="toc-text">组合器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.2.</span> <span class="toc-text">自定义错误类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.3.</span> <span class="toc-text">归一化不同的错误类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8thiserror"><span class="toc-number">16.4.</span> <span class="toc-text">使用thiserror</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-rust"><span class="toc-number">17.</span> <span class="toc-text">unsafe rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">17.1.</span> <span class="toc-text">裸指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsafe%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E7%89%B9%E5%BE%81"><span class="toc-number">17.2.</span> <span class="toc-text">unsafe函数、方法与特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFI%EF%BC%88Foreign-Function-Interface%EF%BC%89"><span class="toc-number">17.3.</span> <span class="toc-text">FFI（Foreign Function Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-%E5%BA%93"><span class="toc-number">17.4.</span> <span class="toc-text">实用工具(库)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">17.5.</span> <span class="toc-text">内联汇编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Macro%E5%AE%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">18.</span> <span class="toc-text">Macro宏编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F-macro-rules"><span class="toc-number">18.1.</span> <span class="toc-text">声明式宏 macro_rules!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="toc-number">18.2.</span> <span class="toc-text">过程宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#derive%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="toc-number">18.3.</span> <span class="toc-text">derive过程宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AE%8F"><span class="toc-number">18.4.</span> <span class="toc-text">属性宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%87%BD%E6%95%B0%E5%AE%8F"><span class="toc-number">18.5.</span> <span class="toc-text">类函数宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">多线程并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.1.</span> <span class="toc-text">使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">19.2.</span> <span class="toc-text">线程同步：消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%94%81%E3%80%81Condvar-%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">19.3.</span> <span class="toc-text">线程同步：锁、Condvar 和信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9AAtomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">19.4.</span> <span class="toc-text">线程同步：Atomic 原子类型与内存顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Send-%E5%92%8C-Sync"><span class="toc-number">19.5.</span> <span class="toc-text">Send 和 Sync</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">20.</span> <span class="toc-text">全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.1.</span> <span class="toc-text">编译期初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.2.</span> <span class="toc-text">运行期初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">异步编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">22.</span> <span class="toc-text">自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BC%96%E5%86%99"><span class="toc-number">22.1.</span> <span class="toc-text">测试编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">22.2.</span> <span class="toc-text">单元测试与集成测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GitHub-Actions%EF%BC%88CI%EF%BC%89"><span class="toc-number">22.3.</span> <span class="toc-text">GitHub Actions（CI）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark"><span class="toc-number">22.4.</span> <span class="toc-text">基准测试benchmark</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/06/%E3%80%90%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91Binary-Ninja-4-1-Decompiler-Design/" title="【博文笔记】Restructuring the Binary Ninja Decompiler"><img src="/images/misc/default_cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【博文笔记】Restructuring the Binary Ninja Decompiler"/></a><div class="content"><a class="title" href="/2024/07/06/%E3%80%90%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91Binary-Ninja-4-1-Decompiler-Design/" title="【博文笔记】Restructuring the Binary Ninja Decompiler">【博文笔记】Restructuring the Binary Ninja Decompiler</a><time datetime="2024-07-06T14:07:33.000Z" title="发表于 2024-07-06 22:07:33">2024-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/Rust-OLLVM%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%9A%84%E9%82%AA%E6%81%B6%E7%BB%84%E5%90%88/" title="Rust+OLLVM平坦化的邪恶组合"><img src="/images/misc/default_cover4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust+OLLVM平坦化的邪恶组合"/></a><div class="content"><a class="title" href="/2024/07/05/Rust-OLLVM%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%9A%84%E9%82%AA%E6%81%B6%E7%BB%84%E5%90%88/" title="Rust+OLLVM平坦化的邪恶组合">Rust+OLLVM平坦化的邪恶组合</a><time datetime="2024-07-05T15:05:58.000Z" title="发表于 2024-07-05 23:05:58">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/%E4%BD%BF%E7%94%A8qiling%E5%87%BB%E8%B4%A5Pluto-Obfuscator%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%89%88%E5%B9%B3%E5%9D%A6%E5%8C%96/" title="使用qiling击败Pluto-Obfuscator的增强版平坦化"><img src="/images/misc/default_cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用qiling击败Pluto-Obfuscator的增强版平坦化"/></a><div class="content"><a class="title" href="/2024/07/05/%E4%BD%BF%E7%94%A8qiling%E5%87%BB%E8%B4%A5Pluto-Obfuscator%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%89%88%E5%B9%B3%E5%9D%A6%E5%8C%96/" title="使用qiling击败Pluto-Obfuscator的增强版平坦化">使用qiling击败Pluto-Obfuscator的增强版平坦化</a><time datetime="2024-07-04T16:50:14.000Z" title="发表于 2024-07-05 00:50:14">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/04/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Rust学习笔记"><img src="/images/misc/default_cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust学习笔记"/></a><div class="content"><a class="title" href="/2024/07/04/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Rust学习笔记">Rust学习笔记</a><time datetime="2024-07-03T16:30:38.000Z" title="发表于 2024-07-04 00:30:38">2024-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/hello-world/" title="hexo简易使用"><img src="/images/misc/default_cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo简易使用"/></a><div class="content"><a class="title" href="/2024/07/03/hello-world/" title="hexo简易使用">hexo简易使用</a><time datetime="2024-07-03T02:48:27.297Z" title="发表于 2024-07-03 10:48:27">2024-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By JANlittle</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>